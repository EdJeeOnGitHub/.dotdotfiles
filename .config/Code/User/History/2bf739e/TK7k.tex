\documentclass[10pt,xcolor=table]{beamer}
\usepackage[utf8]{inputenc}
\usepackage{charter}
\usepackage{graphicx}

\setbeamertemplate{caption}[numbered]

% math
\usepackage{lmodern}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{mathtools}
\usepackage{bm}

%new font size
\makeatletter
\newcommand\notsotiny{\@setfontsize\notsotiny\@vipt\@viipt}
\makeatother

% for references
\usepackage{natbib}
\usepackage{apalike}

% for color
\usepackage{color}
\definecolor{MyLightGray}{RGB}{200, 200,200}

% for tables
\usepackage{threeparttable}
\usepackage{booktabs,caption}
\newcommand\pct{\rlap{-}}
\usepackage{siunitx}
\sisetup{
input-symbols = {()},
group-digits  = false,
explicit-sign
}
\usepackage{multirow}
\usepackage{tabularx}
\renewcommand<>\cellcolor[1]{\only#2{\beameroriginal\cellcolor{#1}}}

% for algorithms
\usepackage[linesnumbered,ruled]{algorithm2e}

% for code blocks
\usepackage{listings}
\lstset{frame=trBL,
  frameround=fttt,
  language=R,
  breakindent = 0pt,
  xleftmargin = 5mm,
  framexleftmargin=5mm,
  basicstyle={\small\ttfamily},
  commentstyle = {\small\ttfamily},
  numbers=none, 
  stepnumber=1, 
  numberstyle=\scriptsize\color{gray}
}

% for figures
\usepackage{subcaption}

%% Title slide formatting %%
% \pgfdeclareimage[width=\paperwidth]{titlebackground}{images/title-slide-background.png}
\setbeamerfont{subtitle}{size=\small}
\setbeamertemplate{title page}{
    \begin{picture}(0,0)
        \put(0,-90){%
            \begin{minipage}[b][5cm][t]{1\textwidth}
                \color{chicagomaroon}
                \usebeamerfont{title}
                    {\inserttitle\\[4cm]} % adjust this depending on title length
                \usebeamerfont{subtitle}
                    {\sc{Edward Jee} \par
                    \sc{Thomas  Wiemann}  \par}
                    {\textit{University of Chicago}\par \vspace{2em}}
                    {\insertdate \vspace{0.8em}}

            \end{minipage}
        }
    \end{picture}
}

%% General slide formatting %%
\definecolor{chicagomaroon}{RGB}{128,0, 0}

\pgfdeclareimage[width=2.5cm]{uchicago_logo}{images/uchicago_logo.png}

\setbeamertemplate{headline}
{%
    \begin{picture}(0,0)
        %\put(275, -28){%
        %    \pgfuseimage{uchicago_logo}
        %}
        \put(20,-27.5){%
            \rule{320pt}{0.4pt}
        }
    \end{picture}
}

\setbeamertemplate{frametitle}
{%
    \begin{picture}(0,0)
        \put(-8,-10){%
            \large\color{chicagomaroon}\insertframetitle
        }
    \end{picture}
}

\setbeamertemplate{footline}
{%
    \begin{picture}(0,0)
        \put(20, 10){
        \notsotiny \color{chicagomaroon} Jee \& Wiemann}
        \put(140,10){% adjust this depending on text length
            \notsotiny \color{chicagomaroon}\insertshorttitle
        }
        \put(337,10){%
            \notsotiny \color{chicagomaroon}\insertframenumber$/$\pageref{lastpage}
        }
    \end{picture}%
}

\setbeamertemplate{navigation symbols}{}

\title[Statistical Programming with \textsf{R} (Pt. II)]{Introduction to Statistical Programming with \textsf{R} \linebreak (Part. II)} % short title for footer


%% Content of slides %%
\begin{document}
\setbeamercovered{transparent}

    %%% Title page
    \begin{frame}[plain]
        \titlepage
    \end{frame}

    %%% Outline
    \begin{frame}{Outline}
        
        \begin{enumerate}\setlength\itemsep{1em}
            \item Data Types
            \item Operators
            \item Functions 
            \item Documentation
            \item Style Guide 
            \item Coding in \textsf{R} Studio
        \end{enumerate}
    \end{frame}
    

    
    
        %%% Data Types
    \begin{frame}{Data Types}
    \vfill
The simplest kind of variables in \textsf{R} are \textit{atomic types}. These do not have an internal structure. Examples are:
\begin{itemize}
    \item \texttt{integer: 1L, 2L, 42L,} $\ldots$
    \item \texttt{numeric: pi, 0.25, Inf,} $\ldots$
    \item \texttt{logical: TRUE, FALSE}.
    \item \texttt{character: "lorem ipsum", "a", "",} $\ldots$
\end{itemize}
    \vfill
    More complex data types are combinations of atomic types. It's useful to organize the most common data types based on their dimensionality and whether they are homogeneous (i.e., whether all of it's contents must be of the same type).  
    
    
    \begin{table}[!htbp] \footnotesize 
  \centering 
  \begin{threeparttable}
\begin{tabular}{lll}
\toprule
\midrule
& Homogeneous & Heterogeneous \\ \midrule
1d& Atomic vector& List\\
2d& Matrix& Data frame\\
nd & Array& \\
\midrule
\bottomrule
\end{tabular}
    \end{threeparttable}
\end{table}

    \end{frame}
    
            %%% Data Types: Atomic vectors
    \begin{frame}[fragile]{Data Types: Atomic vectors}
    \vfill
    Atomic vectors are usually created with \texttt{c()}, short for combine. Even when nesting, atomic vectors are always flat. 
    \vfill
    \textsf{R} does not have any scalar variables. Single numbers or characters are vectors of length 1. Vectors of length 0 also exist (and are a common cause for bugs). 
    
                    \begin{lstlisting}[language = R, title ={Example: Atomic vectors}]
c(1L, c(2L, c(3L, 4L))) # integer
#> [1] 1 2 3 4

c(1, 2, 3, 4) # numeric
#> [1] 1 2 3 4

c(T, F) # logical
#> [1] TRUE FALSE

c("these are", "some strings") # character
#> [1] "these are" "some strings"
        \end{lstlisting}
\vfill
    \end{frame}
    
                %%% Data Types: Factors
    \begin{frame}[fragile]{Data Types: Factors}
    \vfill
    Another fundamental data type that is essentially a vector with attributes is \texttt{factor}. These are used to store categorical and ordinal variables.
    \vfill
    Factor variables can easily be initialized from an existing vector by using \texttt{factor()}.
    
                    \begin{lstlisting}[language = R, title ={Example: Factors}]
factor(c("red", "blue", "green", "red", "green"))
#> [1] red blue green red green
#> Levels: blue green red

factor(c(1, 2, 1, 2, 3))
#> [1] 1 2 1 2 3
#> Levels: 1 2 3
        \end{lstlisting}
\vfill
    \end{frame}
    
    
    
     %%% Data Types: Matrix
    \begin{frame}[fragile]{Data Types: Matrices}
    \vfill
    A two-dimensional collection of atomic vectors is a \texttt{matrix}. They are convenient for storing and manipulating data with linear algebra. 
    \vfill
    Matrices are easily initialized with \texttt{matrix()}. Note that \textsf{R} uses column-wise initialization of matrices. Vectors (or matrices) of appropriate dimension may also be combined via row- or column-concatenation using \texttt{rbind()} or \texttt{cbind()}.
                    \begin{lstlisting}[language = R, title ={Example: Matrices}]
matrix(c(1, 2, 3, 4), ncol = 2, nrow = 2) 
#>       [, 1] [, 2] 
#> [1, ]    1     3
#> [2, ]    2     4

cbind(c(1, 2), c(3, 4))
#>       [, 1] [, 2] 
#> [1, ]    1     3
#> [2, ]    2     4
        \end{lstlisting}
\vfill
    \end{frame}
    
         %%% Data Types: Arrays
    \begin{frame}[fragile]{Data Types: Arrays}
    \vfill
    The n-dimensional generalization of \texttt{matrix} is called \texttt{array}. They are much less common but it's good to be aware of them.
    \vfill
    Use \texttt{array()} for initialization. 
                    \begin{lstlisting}[language = R, title ={Example: Arrays}]
array(c(1:8), dim = c(2, 2, 2))
#> , , 1
#>       [, 1] [, 2]
#> [1, ]    1     3
#> [2, ]    2     4
#> 
#> , , 2
#>       [, 1] [, 2]
#> [1, ]    5     7
#> [2, ]    6     8
        \end{lstlisting}
\vfill
    \end{frame}
    
             %%% Data Types: List
    \begin{frame}[fragile]{Data Types: Lists}
        \vfill
    A \texttt{list} is a 1-dimensional data type with elements of arbitrary type. Note that this is their key difference to atomic vectors. 
    \vfill
    Use \texttt{list()} for initialization (instead of \texttt{c()}).
                    \begin{lstlisting}[language = R, title ={Example: Lists}]
list(1:3, "a", TRUE, 1L)
#> [[1]]
#> [1] 1 2 3
#> 
#> [[2]]
#> [1] "a"
#> 
#> [[3]]
#> [1] TRUE
#> 
#> [[4]]
#> [1] 1
        \end{lstlisting}
\vfill
    \end{frame}
    
    
                 %%% Data Types: Data frames
    \begin{frame}[fragile]{Data Types: Data frames}
    \vfill
    Data frames are the most common way of storing data in \textsf{R}. Essentially, a data frame is a list of equal-length vectors. Given this construction, it shares some properties of both the matrix and the list, which can be very convenient for data analysis.
    \vfill
    Use \texttt{data.frame()} for initialization. Multiple data frames (of appropriate dimension) may be concatenated via \texttt{rbind()} or \texttt{cbind()}.
                    \begin{lstlisting}[language = R, title ={Example: Data frames}]
data.frame(x = 2:4, y = c("a", "b", "c"))
#>   x y
#> 1 2 a
#> 2 3 b
#> 3 4 c
        \end{lstlisting}
\vfill
    \end{frame}
    

                     %%% Data Types: Which one to choose?
    \begin{frame}{Data Types: Which one to choose?}
    \vfill
    Sometimes the data gives you little choice in the data structure. More often than not, however, you have to make the decision. Doing so incorrectly can have noticeable consequences. Poor choices can make your code needlessly complicated, slow, and memory-intensive. 
\vfill
As a simple guideline for the choice between data frames and matrices, consider how linear algebra intensive your code is. If you're using linear algebra operations frequently, use a \texttt{matrix} instead of a data frame. 
\vfill
For advanced projects (outside the scope of this course), also consider other data structures provided by \textsf{R} packages (e.g., \texttt{data.table}, sparse matrices). 
\vfill
    \end{frame}
    
        %%% Questions
    %\begin{frame}{Questions -- Comments -- Suggestions} \vfill
    %    Questions? \vfill
    %    
    %    Comments? \vfill
    %    
    %    Suggestions? \vfill \vfill \vfill \vfill \vfill
    %\end{frame}
    
    
        %%% Operators
    \begin{frame}{Operators}\vfill
    Operators are convenient shortcuts to many of the key operations that frequently arise in data analysis. The key groups of operators are \vspace{0.5em}
    \begin{itemize}\setlength\itemsep{1em}
        \item Assignment operators
        \item Arithmetic operators
        \item Relational operators
        \item Logical operators
        \item Subsetting operators
    \end{itemize}
\vfill
We'll discuss each briefly and conclude with a note on operator preference.
        \vfill
        (There are also two linear algebra operators. We'll turn to them later.)
    \end{frame}
    
            %%% Operators: Assignment
    \begin{frame}[fragile]{Operators: Assignment} \vfill
    Assignment associates an internal object (e.g., a vector of integers) with a variable in your code. The key assignment operator in \textsf{R} is ``\texttt{<-}''. It's not the only one -- but it's the only one you should use. \vfill
    
    There are other assignment operators you may sometimes see in other's code. ``\texttt{=}'' is identical to ``\texttt{<-}'' and both deal with local assignment. The global assignment operator in \textsf{R} is ``\texttt{<<-}''.
    

        
\begin{lstlisting}[language = R, title ={Assignment: Assignment Operators}]
x <- c(1, 2)
x # print(x)
#> [1] 1 2 

y <- cbind(x, x)
y # print(y)
#>       [, 1] [, 2] 
#> [1, ]    1     1
#> [2, ]    2     2
        \end{lstlisting}
\vfill
    \end{frame}
    
    %%% Operators: Arithmetic
    \begin{frame}[fragile]{Operators: Arithmetic} \vfill
    The familiar arithmetic operators are implemented with their usual symbols. In particular, ``\texttt{+}'' is addition, ``\texttt{-}'' is subtraction, ``\texttt{*}'' is multiplication, ``\texttt{/}'' is division, and `` $\hat{}$ '' is the exponent operator. There are two other useful operators: ``$\texttt{\%\%}$'' calculates the modulus and ``$\texttt{\%/\%}$'' calculates integer division.  \vfill
    
    Note that these operations are element-wise! \textsf{R} is vectorized.
    
\begin{lstlisting}[language = R, title ={Example: Arithmetic Operators}]
c(1, 2, 3, 4) + 1
#> [1] 2 3 4 5

c(1, 2, 3, 4) * c(1, 2, 3, 4)
#> [1] 1 4 9 16

c(3, 4, 5, 6) %% 3
#> [1] 0 1 2 0
        \end{lstlisting}
\vfill
    \end{frame}
    
    
        %%% Operators: Relational
    \begin{frame}[fragile]{Operators: Relational} \vfill
    Relational operators are very convenient for generation of logical variables. In \textsf{R}, the key relational operators are the familiar ``greater than'' and ``smaller than'' operators -- ``\texttt{>}'' and ``\texttt{<}'' -- as well as their weak extensions --  ``\texttt{>=}'' and ``\texttt{<=}''. Equality is indicated by a double equality sign: ``\texttt{==}''. Not-equal is using the negation operator: ``\texttt{!=}''.  \vfill
        
    As before: these operations are element-wise!
        
\begin{lstlisting}[language = R, title ={Example: Relational Operators}]
x <- 1
y <- x + 1
c(y < x, y <= x, y != x)
#> [1] FALSE FALSE TRUE

(c(3, 4, 5, 6) %% 3) == 0
#> [1] TRUE FALSE FALSE TRUE
        \end{lstlisting}
\vfill
    \end{frame}
    
            %%% Operators: Logical
    \begin{frame}[fragile]{Operators: Logical} \vfill
    Logical operators are convenient for aggregating logical variables. Here, ``\texttt{\&}'' is element-wise \textit{logical-and}, and ``\texttt{|}'' is element-wise \textit{logical-or}. The negation operator is ``\texttt{!}''. \vfill

    In addition to the element-wise logical operators, there are also non-element-wise alternatives --  ``\texttt{\&\&}'' and ``\texttt{||}''. Both only evaluate the first logical variable. Be cautious when using them.
        
        \begin{lstlisting}[language = R, title ={Example: Logical Operators}]
!(c(TRUE, FALSE) & TRUE)
#> [1] FALSE TRUE

x <- 1
y <- x + 1
(y < x - 1) | (y > x)
#> [1] TRUE

(c(1, 2, 3, 4) == c(1, 5, 5, 5)) && (x == 1)
#> [1] TRUE
        \end{lstlisting}
\vfill
    \end{frame}
    
    
    
        %%% Operators: Subsetting
    \begin{frame}[fragile]{Operators: Subsetting} \vfill
        Subsetting allows you to retrieve and manipulate parts of your data structure. This is crucial for succinctly expressing complex operations. \vfill
        \textsf{R} has three subsetting operators: 
        \begin{itemize}
            \item \texttt{[} for vectors, matrices, arrarys, and data frames
            \item \texttt{[[} for lists
            \item $\$$ for named lists and data frames
        \end{itemize}
        
\begin{lstlisting}[language = R, title ={Example: Subsetting Operators}]
df <- data.frame(x = 2:4, y = c("a", "b", "c"))
df[, 1] 
#> [1] 2 3 4

df[, 1] == df[, "x"] & df[, 1] == df$x
#> [1] TRUE TRUE TRUE
        \end{lstlisting}
\vfill
    \end{frame}
    
                %%% Operators: Precedence
    \begin{frame}[fragile]{Operators: Precedence} \vfill
        Precedence rules for operators can be complicated. Rather than memorize these rules and risk confusion, use parentheses to avoid ambiguity. \vfill
        
                        \begin{lstlisting}[language = R, title ={Example: Operator Precedence}]
TRUE || FALSE == FALSE || FALSE
#> [1] TRUE

(TRUE || FALSE) == (FALSE || FALSE)
#> [1] FALSE

TRUE || (FALSE == FALSE) || FALSE
#> [1] TRUE
        \end{lstlisting} \vfill
        
    \end{frame}
    
         %%% Questions
    %\begin{frame}{Questions -- Comments -- Suggestions} \vfill
    %    Questions? \vfill
    %    
    %    Comments? \vfill
    %    
    %    Suggestions? \vfill \vfill \vfill \vfill \vfill
    %\end{frame}

        %%% Functions
    \begin{frame}[fragile]{Functions} \vfill
        Functions are a fundamental building block of \textsf{R}: Anything that ``happens'' is the result of a function call. \vfill
        Much like it's mathematical equivalent, a function takes some inputs (called \textit{arguments}) and returns an output. In \textsf{R}, a function can only return a single object (e.g., a vector or a list). \vfill
        Writing your own functions is -- thankfully -- incredibly easy. If you catch yourself copy-pasting lines of code, consider writing your own function and calling it instead.
                             \begin{lstlisting}[language = R, title ={Example: Custom Functions}]
myplus <- function(x, y) {
  res <- x + y 
  return(res)
}#MYPLUS

myplus(1, 2) == (1 + 2)
#> [1] TRUE
        \end{lstlisting} \vfill
        
    \end{frame}
    
            %%% Functions
    \begin{frame}[fragile]{Functions} \vfill
    Base \textsf{R} implements many key functions for data analysis. Being familiar with them is important for efficient programming. \vfill
    Some of the key function groups are:\vspace{0.5em}
    \begin{itemize}\setlength\itemsep{1em}
        \item Distributional functions
        \item Statistical functions
        \item Logical functions
        \item Linear Algebra
        \item Importing and Exporting Data
    \end{itemize}
    \vfill
    We'll briefly go over each now.
    \end{frame}
    
    
      %%% Functions: Distributions
    \begin{frame}[fragile]{Functions: Distributions} \vfill
    The four key distributional functions we need are 
    \begin{itemize}
        \item the probability density (mass) function,
        \item the cumulative density (mass) function,
        \item the quantile function,
        \item the sampling function for generating random draws.
    \end{itemize}
    \vfill
    \textsf{R} implements these for all standard distributions with the same pattern: \vfill
    \texttt{(d, p, q, r) * (binom, chisq, exp, f, norm, t, unif)}\vfill
    where \texttt{d} denotes the pdf (pmf), \texttt{p} denotes the CDF (CMF), \texttt{q} denotes the quantile function, and \texttt{r} denotes the sampling function. 
    \vfill\texttt{binom} denotes the binomial distribution, \texttt{chisq} denotes the $\chi^2$-distribution, \texttt{exp} denotes the exponential distribution, \texttt{f} denotes the F-distribution, \texttt{norm} denotes the normal distribution, \texttt{t} denotes the t-distribution, and \texttt{unif} denotes the uniform distribution.
\vfill
(Note: There are many other distributions implemented in \textsf{R}!)\vfill
    \end{frame}

       %%% Functions: Sample Statistics
    \begin{frame}[fragile]{Functions: Sample Statistics}\vfill
    Sample statistics are functions of the observed data. They are useful for summarizing key features of the data.\vfill
    Particularly useful functions are:
    \begin{itemize}
        \item \texttt{sum}, \texttt{mean}, \texttt{sd}, \texttt{var} 
        \item \texttt{cov}, \texttt{cor}
        \item \texttt{quantile}
        \item \texttt{table}
    \end{itemize} \vspace{-1.25em}
            \begin{lstlisting}[language = R, title ={Example: Sample Statistics}]
x <- rexp(n = 100000, rate = 2) # E[X] = 1/2
mean(x)
#> [1] 0.501

x <- rnorm(n = 10000, mean = 0, sd = 1)
quantile(x = x, probs = c(0.025, 0.975))
#>   2.5%  97.5% 
#> -1.967  1.947
        \end{lstlisting}
\vfill
    \end{frame}
    
        
          %%% Functions: Sample Statistics
    \begin{frame}[fragile]{Functions: Sample Statistics (Contd.)} \vfill
    In the example below, we test the fairness of an unfair coin given a sample of $n = 100$ observations. Recall that a binomial random variable with 1 trial is simply a Bernoulli random variable.
            \begin{lstlisting}[language = R, title ={Example: Test fairness of a coin flip}]
# Simulate data from Bernoulli s.t. E[X] = 0.6.
#     That is, the coin is unfair!
n <- 100
x <- rbinom(n = n, size = 1, prob = 0.6)

# Calculate test statistic for H_0: E[X] = 0.5.
z <- sqrt(n) * (mean(x) - 0.5) / sd(x)

# Conduct two sided test using the CLT.
2 * pnorm(q = -abs(z), mean = 0, sd = 1) 
#> [1] 0.002
        \end{lstlisting}
\vfill
    \end{frame}
    
           %%% Functions: Linear Algebra
    \begin{frame}[fragile]{Functions: Linear Algebra} \vfill
    Linear algebra is incredibly useful for econometrics and statistics -- both for theory and for implementation. \vfill
    The key functions are \begin{itemize}
        \item the transpose function: \texttt{t}
        \item the inverse function: \texttt{solve}
        \item matrix multiplication: \texttt{\%*\%}
        \item out product: \texttt{\%o\%}
    \end{itemize} \vfill
    Implementing linear regression from scratch has never been so easy! Recall $\hat{\beta}_{ols} = \left(X^\top X\right)^{-1} X^\top y.$
            \begin{lstlisting}[language = R, title ={Example: Linear Algebra}]
myols <- function(y, X) {
  beta <- solve(t(X) %*% X) %*% (t(X) %*% y)
  return(beta)
}#MYOLS
        \end{lstlisting}
\vfill

    \end{frame}
    
               %%% Functions: Logical functions
    \begin{frame}[fragile]{Functions: Logical functions} \vfill
    The key logical functions are 
    \begin{itemize}
        \item \texttt{any} 
        \item \texttt{all}
        \item \texttt{which}
    \end{itemize} \vfill
    Two others that are sometimes convenient are \texttt{which.min} and \texttt{which.max}.\vspace{-1em}

            \begin{lstlisting}[language = R, title ={Example: Logical Functions}]
x <- c(TRUE, FALSE, TRUE)
any(x)
#> [1] TRUE

all(x)
#> [1] FALSE

which(x)
#> [1] 1 3
        \end{lstlisting}
\vfill

    \end{frame}
    
               %%% Importing and Exporting Data
    \begin{frame}[fragile]{Functions: Importing and Exporting Data} \vfill
    Here we discuss importing and exporting comma separated values-files (i.e., csv-files). This can easily be done with \texttt{read.csv} and \texttt{write.csv}. \vfill
    
    There are many \textsf{R} packages for importing other file formats. See, e.g., \texttt{readstata13}, \texttt{haven}, etc.  \vspace{-1em}
            \begin{lstlisting}[language = R, title ={Example: Importing and Exporting Data}]
# Simulate some data
n <- 100
df <- data.frame(x = rnorm(n, 0, 1), 
                 y = rbinom(n, 1, 0.6))

# Export to .csv
write.csv(df, file = "my_simulated_data.csv",
          row.names = FALSE)

# Import from .csv
df_2 <- read.csv(file = "my_simulated_data.csv")
head(df_2$y) # prints first 5 entries
#> [1] 0 1 0 1 1
        \end{lstlisting}
\vfill
    \end{frame}
    
                   %%% Functions: Logical functions
    \begin{frame}[fragile]{Functions: Packages} \vfill
    Base \textsf{R} is great (and you should use it) but there are excellent extensions available in the form of packages. \vfill
    Official packages are hosted on CRAN. These packages are well maintained and have to adhere to certain quality standards. Examples are \texttt{ggplot2} for plotting or \texttt{dyplr} for data manipulation. \vfill
    In-official packages (or development versions) are often hosted on GitHub. Using the package \texttt{devtools}, these can be directly installed as well. \vfill
    After installation, packages need to be activated each time you want to use them. This is done via \texttt{library}. \vspace{-1em}
            \begin{lstlisting}[language = R, title ={Example: Installing Packages}]
# CRAN packages
install.packages(c("ggplot2", "dyplr", "devtools"))

# GitHub package
library(devtools)
install_github("jkcshea/l1svr") # needs devtools
        \end{lstlisting}
\vfill

    \end{frame}
    
              %%% Resources
    \begin{frame}{Documentation}\vfill
    Before calling a function, it's important you familiarize yourself with the syntax and default arguments. The perfect resource for this are the \textsf{R} help files. These can be conveniently accessed via the ``\texttt{?}'' operator.\vfill
    
    The following is a screenshot from the output after calling \texttt{?rnorm}. \vfill
           \begin{figure} \vspace{-1em}
            \centering
            \includegraphics[width=0.8\textwidth]{images/Discussion-2/rdoc.png}
            \label{fig:my_label}
        \end{figure} \vspace{-1em} \vfill
    Other helpful resources are Google, Stack Overflow, Stack Exchange, etc.     
        \vfill
    \end{frame}
    
    
          %%% Questions
    %\begin{frame}{Questions -- Comments -- Suggestions} \vfill
    %    Questions? \vfill
    %    
    %    Comments? \vfill
    %    
    %    Suggestions? \vfill \vfill \vfill \vfill \vfill
    %\end{frame}
    

    %%% Style-Guide
    \begin{frame}{Style-Guide}
    \vfill
    ``\textit{Good coding style is like using correct punctuation. You can manage without it, but it sure makes things easier to read.}'' -- \citet{wickham2019advanced}
    \vfill
    Adopting (and adapting) a so-called style guide is the better alternative to re-inventing punctuation from scratch. The following gives a few highlights from the \texttt{tidyverse} style guide (\url{https://style.tidyverse.org/}).  
    \vfill
    We focus on:
    \begin{itemize}
        \item Naming
        \item Spacing 
        \item Comments
        \item Sections
    \end{itemize}
    \vfill
    \end{frame}
    
     %%% Style-Guide: Naming
        \begin{frame}[fragile]{Style-Guide: Naming} \vfill
    Coming up with good variable names can be challenging!          \vfill
    
        \begin{itemize}
            \item Variable and function names should be in lowercase.
            \item Use an underscore to separate words withing a name.
            \item Variable names should be nouns and function names should be verbs.
            \item Strive for names that are clear and concise.
        \end{itemize}
                \begin{lstlisting}[language = R, title ={Example: Variable names}]
# Good
sample_mean_x <- mean(x) 
avg_x <- mean(x)

# Bad
SampleMean_1 <- mean(x)
avgx <- mean(x)
        \end{lstlisting}
         \vfill

    \end{frame}
    
    %%% Style-Guide: Spacing 
        \begin{frame}[fragile]{Style-Guide: Spacing} \vfill
    
        \begin{itemize}
            \item Place spaces around all infix operators (\texttt{=, +, -, <-,} etc.). The exception is ``\texttt{:}'', which should be used without spaces.
            \item Always put a space after a comma, and never before.
            \item Place spaces before left parentheses, except in a function call.
            \item Don't add space within parentheses.
        \end{itemize}
                \begin{lstlisting}[language = R, title ={Example: Spacing}]
# Good
x <- 1:10
if (1 %in% x) print("Wow!")
x <- c(x, x)

# Bad
x <- 1 : 10
if(1%in%x)print("Wow!")
x <- c ( x , x )
        \end{lstlisting}
         \vfill

    \end{frame}
    
    
        %%% Style-Guide: Comments
    \begin{frame}[fragile]{Style-Guide: Comments}
    \vfill
        \begin{itemize}
            \item Use \texttt{\#} to add a comment.
            \item Comment frequently but not excessively. 
            \item For multi-line comments, add \textit{four} spaces at the beginning of each line after the first one. 
        \end{itemize} \vfill
        
            Important: Limit your code to 80 characters per line. Many IDEs add a vertical line to help with this.
        
        \begin{lstlisting}[language = R, title ={Example: Multi-line comment}]
# Commenting code is important. Be concise. When 
#     necessary, use indentation to increase
#     readability. 
        \end{lstlisting}
        
\begin{lstlisting}[language = R, title ={Example: Simple comment}]
x <- 1 
x <- x + 1 # This works well for brief comments
\end{lstlisting}


    
    \vfill
    \end{frame}
    
    
    
            %%% %%% Style-Guide: Sections
    \begin{frame}[fragile]{Style-Guide: Sections}
      \vfill  
      Use comments to break up a single \textsf{R} script into multiple sections. For example, each section dedicated to a single exercise of a 
      problem set.
      \vfill
      Using ``\texttt{=}'' does the job nicely:
        \begin{lstlisting}[language = R, title ={Example: Sectioning an \textsf{R} Script}]
# Section name ====================================
# Adding a brief explanation here may be good.

x <- 1 # Some code
x <- x + 1 

# Another section name ============================
# Etc...
\end{lstlisting}

\vfill
    \end{frame}
    
          %%% Questions
    %\begin{frame}{Questions -- Comments -- Suggestions} \vfill
    %    Questions? \vfill
    %    
    %    Comments? \vfill
    %    
    %    Suggestions? \vfill \vfill \vfill \vfill \vfill
    %\end{frame}
    
        
    %%% R Studio
    \begin{frame}{Coding in \textsf{R} Studio}
        
        \begin{figure}
            \centering
            \includegraphics[width=0.9\textwidth]{images/Discussion-2/R-Studio_1.png}
            \label{fig:my_label}
        \end{figure}
    \end{frame}
    
        %%% R Studio
    \begin{frame}{Coding in \textsf{R} Studio (Contd.)}
            \vfill
        There are essentially three options for executing code in \textsf{R} Studio:
        \begin{itemize} \setlength\itemsep{0.75em}
            \item Entering code directly in the  \textsf{R} console. Note that this makes reproduction (practically) impossible.
            \item Selecting a single line in the \textsf{R} script and hitting \texttt{enter}. This runs the line of code and advances to the next line.
            \item Block-selecting multiple lines of code and hitting \texttt{enter}. This runs all selected lines in sequence.
        \end{itemize}
        \vfill
        Frequently run your code to check whether everything works as intended. 
            \vfill
\label{lastpage}
    \end{frame}
    

    
    % References
% \begin{frame}{References} 
% \bibliographystyle{apalike}
% \bibliography{biblio}
% \vfill
% \end{frame}

\end{document}