---
title: "Initial Model Fits"
author: "Ed Jee"
date: '2022-06-18'
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(tidyverse)
library(cmdstanr)
library(ggstance)
library(lubridate)
library(survival)
library(flexsurv)
library(tidybayes)
options(mc.cores = 4)
```

# Load and clean data
```{r}
all_df = read_csv("data/individual_data.csv", guess_max = 10000)
all_df

subset_df = all_df %>%
    filter(!str_detect(study, "Dupas")) %>%
    filter(!str_detect(study, "Kremer"))

clean_df = subset_df %>%
    select(
        study, 
        event_time_lb,
        event_time_ub,
        follow_up_time, 
        treatment_time, 
        death, 
        wtreatment,
        age_month, 
        precision_evt
    ) %>%
    mutate(
        cens_event_time_lb = if_else(
            death == 0,
            follow_up_time,
            event_time_lb
        ),
        cens_event_time_ub = if_else(
          death == 0,
          follow_up_time,
          event_time_ub
        ),
        left_interval = interval(treatment_time, cens_event_time_lb) %/% days(1), 
        right_interval = interval(treatment_time, cens_event_time_ub) %/% days(1),
    ) %>%
    group_by(study) %>%
    mutate(site_id = cur_group_id()) %>%
    ungroup() %>%
    filter(!is.na(death)) %>%
    mutate(censoring = if_else(death == 0, 0, 
        ifelse(left_interval == right_interval, 1, 3)), 
        right_interval = right_interval + ifelse(left_interval == 0, 1, 0),
        left_interval = left_interval + ifelse(left_interval == 0, 1, 0)) %>%
    filter(!is.na(left_interval) & !is.na(right_interval))
```

# Fit frequentist survival models to obtain point estimates
```{r}
# Create survival modeling functions
mods = c("exp", "weibull")  # Excluding Gompertz for now due to fitting issues
surv_mod = function(x, mod) {
  flexsurvreg(Surv(left_interval, right_interval, death, type = "interval")
              ~ as.factor(wtreatment), data = x, dist=mods[mod])
}
poss_surv_mod = possibly(surv_mod, otherwise = NULL)

# split by groups
df_list = clean_df %>%
  select(site_id, left_interval, right_interval, death, wtreatment) %>%
  group_by(site_id) %>%
  group_split()
df_list

tidy_fits = list()
for (mod in 1:2) {  # Note: Weibull doesn't converge for 2 studies
  # map over separate dfs and fit linear model
  fit_list = df_list %>%
    map(~poss_surv_mod(x = .x, mod))
  fit_list
  
  # map over list of fits and tidy them up.
  # imap creates a variable .y that acts as a counter for each list object 
  # _dfr says combine the final results into a dataframe by row    
  fit_list = fit_list %>%
    imap_dfr(~broom::tidy(.x, conf.int = TRUE) %>% mutate(site_id = .y, type = mods[mod])) 
  tidy_fits[[mod]] = fit_list %>% 
    filter(str_detect(term, "treatment")) %>% 
    mutate(model_type = "frequentist")
}
```

# Fit Bayesian models
```{r}
stan_df = clean_df # %>% sample_frac(0.1)
surv_model = cmdstan_model("survival-stan/hierarchical-survival.stan")

stan_draws = list()
for (i in 1:2) {  # Gompertz (3) didn't work: "No chains finished successfully. Unable to retrieve the fit."
  stan_data = list(
      interval_left = stan_df$left_interval,
      interval_right = stan_df$right_interval,
      N = nrow(stan_df),
      J = length(unique(stan_df$study)),
      nc = 2,
      nsc = 100,
      site = stan_df$site_id, 
      X = stan_df %>% mutate(const = 1) %>% select(const, wtreatment) %>% as.matrix(),
      censoring = stan_df$censoring,
      beta_mean = c(0, 0),
      beta_sigma = c(1, 1),
      model_type = i
  )
  
  surv_fit = surv_model$sample(stan_data)
  stan_draws[[i]] = surv_fit %>% gather_draws(beta[site_id, k])
}

site_name = clean_df %>%
  select(study, site_id) %>%
  unique()
site_name

tidy_stan_draws = function(stan_draws) {
  stan_draws %>%
  median_qi() %>%
  filter(k == 2) %>%
  to_broom_names() %>% 
  mutate(model_type = "bayesian")
}

plot_est <- function(i) {
  compare_fits = bind_rows(tidy_fits[[i]], all_tidy_draws[[i]]) %>%
    left_join(site_name, by = "site_id") 
  
  # Just plot Bayes model results
  # bayes_plot <- compare_fits %>%
  #   filter(model_type == "bayesian") %>%
  #   ggplot(aes(
  #     x = estimate,
  #     xmin = conf.low,
  #     xmax = conf.high,
  #     y = study,
  #     colour = factor(site_id)
  #   )) +
  #   geom_pointrangeh() +
  #   geom_vline(xintercept =  0, linetype = "longdash") +
  #   theme_bw() 
  # print(bayes_plot)
  
  # Plot Bayesian vs. frequentist models
  both_plot <- compare_fits %>%
    ggplot(aes(
      x = estimate,
      xmin = conf.low,
      xmax = conf.high,
      y = study,
      colour = model_type
    )) +
    geom_pointrangeh(position = position_dodge2v(0.5)) +  #Q: Why "missing values"? Are the bars just going off the plot?
    geom_vline(xintercept = 0, linetype = "longdash") +
    theme_bw() +
    xlim(-10, 10) + 
    ggtitle(paste("Model:", compare_fits$type[1]))
  print(both_plot)
}

all_tidy_draws = map(stan_draws, tidy_stan_draws)
all_plots = map(1:2, plot_est)
```

```{r}
stanfit <- rstan::read_stan_csv(weibull_fit$output_files())
shinystan::launch_shinystan(stanfit)
weibull_fit
```